 StatsDoc←{
     _←⍬
     _,←⊂' generated by Dutils.MakeDoc  using   Dutils.Documentation     '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂'           Quickie Stats Summary                                               '
     _,←⊂79⍴' '
     _,←⊂'          {ns} ← Anova          v  levels  norm                                '
     _,←⊂'          {ns} ← AnovaPool      abt_mms_fr_il_al_si  (6 ⍬s with 1 substitution)'
     _,←⊂79⍴' '
     _,←⊂'          {ns} ← {vnames} RegressMultipleLinear  yv  xvov                      '
     _,←⊂'          {ns} ← {vnames} StepWiseAll            yv  xvov  Fr  Fa  (istart)    '
     _,←⊂'          {ns} ← {vnames} StepWiseOne            yv  xvov  Fr  Fa  (istart)    '
     _,←⊂'          {ns} ← {vnames} RegressPolynmomial     yv  xv    order               '
     _,←⊂'          {ns} ← {vnames} RegressFosythe         yv  xv    order               '
     _,←⊂'          {ns} ← {vnames} RegressChebyshev       yv  xv    order               '
     _,←⊂'          {ns} ← {vnames} RegressFourier         yv  xv    order               '
     _,←⊂'  {qvov names} ← ModelQuadratic                  vov                           '
     _,←⊂'         {vov} ← ModelChebyshev                  ndata order                   '
     _,←⊂79⍴' '
     _,←⊂'          {ns} ← PrincipleComponents    vov                                    '
     _,←⊂79⍴' '
     _,←⊂'          {ns} ← {vnames} Statistics    vov                                    '
     _,←⊂'          {cm} ← {vnames} CorrelMatrix  vov                                    '
     _,←⊂'          {ac} ← AutoCorr               v                                      '
     _,←⊂'          {cc} ← CrossCorr              v_stationary   v_losing_front          '
     _,←⊂'          {ns) ← CrossTabs              v1  v2                                 '
     _,←⊂79⍴' '
     _,←⊂'     {Xans DL} ← SimutaneousEquations   Amat RHSvector                         '
     _,←⊂79⍴' '
     _,←⊂'          {ft} ← DFT                    v                                      '
     _,←⊂'          {ft} ← FFT                    v                                      '
     _,←⊂'          {ns} ← IDFT                  fft                                     '
     _,←⊂'          {ns} ← IFFT                  fft                                     '
     _,←⊂'          {wv} ← {ww} TukeyWindow       v                                      '
     _,←⊂79⍴' '
     _,←⊂'         {vov} ← LeadLag                vov vup¯dn vfill cut_bot cut_top       '
     _,←⊂79⍴' '
     _,←⊂79⍴' '
     _,←⊂79⍴'-'
     _,←⊂'                       in    Stats.Distrib.                                    '
     _,←⊂'             x ← Normal_Xa    ⍺      returns the x for that distributio tail   '
     _,←⊂'             ⍺ ← Normal_Ax    x      returns the ⍺ for that x (distance from 0)'
     _,←⊂'             t ← Student_Tad  ⍺ dof  return critical student_t value           '
     _,←⊂'             ⍺ ← Student_Atd  t dof  return ⍺                                  '
     _,←⊂'             c ← ChiSq_Cad    ⍺ dof  return critical ChiSquare                 '
     _,←⊂'             a ← ChiSq_Acd    c dof  return alpha; given a ChiSquare and DOF   '
     _,←⊂'             f ← Fratio_Fand  ⍺ n d  return critical Fratio;  alpha dof_N dof_D'
     _,←⊂'             ⍺ ← Fratio_Afnd  F n d  return ⍺                                  '
     _,←⊂'             d ← Fratio_Dfan  F ⍺ n  return denominator degrees of freedom     '
     _,←⊂'                    and all of the other logical possibilities                 '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴'='
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' Anova:   n-way Analysis of Variance                                           '
     _,←⊂'              ns  ←  {FactorNames)  Anova  d  f  {p}                           '
     _,←⊂'  Arguments:                                                                   '
     _,←⊂'    d:  vector of data: logically partitioned with the first factor (A) going  '
     _,←⊂'                        the slowest (all values of the first level of A, then  '
     _,←⊂'                        all values for the second levcl of A, etc.) and the    '
     _,←⊂'                        replicates for each cell bunched together:             '
     _,←⊂'       A1 .........................................................    A2 .... '
     _,←⊂'       B1                             B2                  B3 ......    B1      '
     _,←⊂'       C1        C2        ......     C1         C2 ...   C1 C2 ...    C1  C2 .'
     _,←⊂'       D   all levels of D for A1,B1,C1; then all levels of D for A1,B1,C2; ...'
     _,←⊂'       R   (replicates of (A1,B1,C1,D1) R1 R2 ...) then                        '
     _,←⊂'           (replicates of (A1,B1,C1,D2)) R1 R2 ) ... etc.                      '
     _,←⊂79⍴' '
     _,←⊂'    f: the list of factor levels:  If A has 3 levels, B has 4 levels, C has 2  '
     _,←⊂'                          levels, D has 7 levels, and there are 5 replicates   '
     _,←⊂'                          for each case:  f ≡  3 4 2 7 5                       '
     _,←⊂'                          that means:  (≢d) ≡ 840                              '
     _,←⊂'    p: optional:  default=0 ≡ present in the order:  A  B  C ... AB AC ...     '
     _,←⊂'                          1 ≡ present as:  A B AB C AC BC ABC D AD ....        '
     _,←⊂79⍴' '
     _,←⊂'       There can be up to 15 factors with replicates.   The pattern must be    '
     _,←⊂'       complete: every level of A must have every level of each of the other   '
     _,←⊂'       factors, and every case must have the same number of replicates.        '
     _,←⊂'       The vector of numbers is logically the ravel of an n-dimensional matrix '
     _,←⊂'       that is A by B by C by ... by R. (d ≡ ,f ⍴ d)                           '
     _,←⊂79⍴' '
     _,←⊂'  Resultant output:  ns: A (shy) namespace containing the variables:           '
     _,←⊂'              ANOVA_Table   ANOVA_Averages   ANOVA_Residluals  and  ANOVA_Data '
     _,←⊂79⍴' '
     _,←⊂'   Try:  ns ← Anova (⍳64) (2 2 2 2 4)    {You can add error to the data:       '
     _,←⊂'                          ((⍳64)+(64 random numbers))(2 2 2 2 4)               '
     _,←⊂'                          At least Factor A (level 1 values: 1-32)(level 2     '
     _,←⊂'                          values: 33-64) will turn out to be significant for   '
     _,←⊂'                          reasonable sized error.  E.g.:  ((⍳64)+ (.1×64?64)   '
     _,←⊂79⍴' '
     _,←⊂'   If all experiments have replicate 1 first, then replicate 2, then 3, etc.   '
     _,←⊂'   i.e. replicate levelss are going the slowest not the fastest, they can be   '
     _,←⊂'   reordered using the transpose:     r_fast ← .... ⍉  r_slow                  '
     _,←⊂'   If the ≢d ≡ 60 and there are 5 replicates of 12 exeriments where factor a   '
     _,←⊂'   has 3 levels; b has 4 levels -- the logical rho of d is 5 3 4.  It needs to '
     _,←⊂'   be 3 4 5.  So:   d_good ← ,3 1 2 ⍉  5 3 4 ⍴ d_bad                           '
     _,←⊂79⍴' '
     _,←⊂'   My experience has shown that if there are missing data, just fill out the   '
     _,←⊂'   cell with the average (or expected average), and you will get the "big      '
     _,←⊂'   picture".  One way to test this is analyze some the replicates separately.  '
     _,←⊂'   The results should pretty much compare.  Truly significant factors should   '
     _,←⊂'   remain significant.                                                         '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' AnovaPool:   it sometimes helps to bunch some of the factors or interactions  '
     _,←⊂'              that have small F-ratios (large ⍺) into the error pool.          '
     _,←⊂'                  pns ← ns   AnovaPool   number_or_letters                     '
     _,←⊂79⍴' '
     _,←⊂'   Arguments:                                                                  '
     _,←⊂' R      a vector of 6 nulls with one of the nulls replaced (trailing nulls can '
     _,←⊂'        be ignored).                                                           '
     _,←⊂' L      the namespace from the full Anova.                                     '
     _,←⊂79⍴' '
     _,←⊂'   Result is a namespace with the variable:    Pooled_Anova_TAble              '
     _,←⊂79⍴' '
     _,←⊂'   Right argument meanings:                                                    '
     _,←⊂'        pns ← ns AnovaPool ABB {⍬ ⍬ ⍬ ⍬ ⍬}    ⍝ pool All But the "n" Biggest   '
     _,←⊂'                                                     mean squares              '
     _,←⊂'        pns ← ns AnovaPool ⍬ MMS {⍬ ⍬ ⍬ ⍬}    ⍝ pool factors/interactions with '
     _,←⊂'                                                     a mean square < Minimum   '
     _,←⊂'                                                     Mean Square               '
     _,←⊂'        pns ← ns AnovaPool ⍬ ⍬ FR {⍬ ⍬ ⍬}     ⍝ pool F_ratios smaller than FR  '
     _,←⊂'        pns ← ns AnovaPool ⍬ ⍬ ⍬ IL {⍬ ⍬}     ⍝ pool Interaction Levels IL and '
     _,←⊂'                                                     higher.  ABD ≡ 3rd level  '
     _,←⊂'                                                     interaction.              '
     _,←⊂'        pns ← ns AnovaPool ⍬ ⍬ ⍬ ⍬ AL {⍬}     ⍝ pool factors with an alpha ≥ AL'
     _,←⊂'        pns ← ns AnovaPool ⍬ ⍬ ⍬ ⍬ ⍬ SI       ⍝ pool factors that include these'
     _,←⊂'                                                     letters.  if SI ≡ BD then '
     _,←⊂79⍴' '
     _,←⊂'   for example:  pns ← ns AnovaPool 6             would pool all but the 6     '
     _,←⊂'                                                  biggest mean squares.        '
     _,←⊂'                 pns ← ns AnovaPool ⍬ ⍬ 2.3       would pool all F-ratios less '
     _,←⊂'                                                  than 2.3                     '
     _,←⊂'                 pns ← ns AnovaPool ⍬ ⍬ ⍬ 4       would pool all 4, 5, 6...-way'
     _,←⊂'                                                  interactions                 '
     _,←⊂'                 pns ← ns AnovaPool ⍬ ⍬ ⍬ ⍬ ⍬ BD  5 way Anova:  BD would pool  '
     _,←⊂'                                                  B D                          '
     _,←⊂'                                                  AB AD BC BD BE CD DE ABC ABD '
     _,←⊂'                                                  ABE ACD ADE BCD BCE BDE CDE  '
     _,←⊂'                                                  ABCD ABCE ABDE ACDE BCDE     '
     _,←⊂'                                                  ABCDE                        '
     _,←⊂'                                                  In a 5-way Anova (with       '
     _,←⊂'                                                  replicates) there are 31     '
     _,←⊂'                                                  interactions: +/5 10 10 5 1  '
     _,←⊂79⍴' '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' AutoCorr       find cyclical behavior                                         '
     _,←⊂'                   ac ← AutoCorr x                                             '
     _,←⊂79⍴' '
     _,←⊂'   Argument:     x:      a vector of numbers.                                  '
     _,←⊂'   Result:      ac:      a string of correllation coefficients of the x vector '
     _,←⊂'                         with itself shifted over one step at a time.          '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' CorrelationMatrix    the Pearson Correlation between all variables            '
     _,←⊂'                   cm ← CorrelationMatrix   vov                                '
     _,←⊂79⍴' '
     _,←⊂'   Argument:   vov:  a  vector_○f_data_vectors all of the same length          '
     _,←⊂'   Result:     cm:   a matrix of the correlation coefficient between each pair '
     _,←⊂'                     of variables.  The matrix is symetrical about the diagonal'
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' CrossCorr      determine a "time" shift between two variables                 '
     _,←⊂'                   cc ← CrossCorr  x y                                         '
     _,←⊂79⍴' '
     _,←⊂'   Arguments:  x y:   two vectors of equal length.                             '
     _,←⊂'   Result:     cc:    a string of correlation coefficients between the x vector'
     _,←⊂'                      and the y vector where succeeding values are dropped from'
     _,←⊂'                      the end of x and the beginning of y.  A "bump" would     '
     _,←⊂'                      indicate a correlation shifted in "time" where y lags x. '
     _,←⊂'                      Switching x and y would indicate x lagging y.            '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' CrossTabs      Chi-Square analysis of two "catagorical" vectors.              '
     _,←⊂'                    ns ← CrossTabs  v w                                        '
     _,←⊂79⍴' '
     _,←⊂'   Arguments:  v w:  two vectors of the same length of "categorical" data.     '
     _,←⊂'                     The variables a usualy coded to match the responses to    '
     _,←⊂'                     questionaires or otherwise counted data.                  '
     _,←⊂'                     v could be political party and w could be religion asked  '
     _,←⊂'                     of a group of people.  v might be coded: 1=Jewish,        '
     _,←⊂'                     2=Catholic, 3=Muslim, 4=Morman, etc.  w might be coded:   '
     _,←⊂'                     1=Democratic, 2=Republican, 3=Independent, 4=Communist....'
     _,←⊂'                     A matrix is formed that would have the count for each     '
     _,←⊂'                     pair of options.  The rows will be religion; the columns  '
     _,←⊂'                     will be party.                                            '
     _,←⊂'                     99 is interpreted as Missing and the data are uncounted.  '
     _,←⊂'                     ¯1 is interpreted as deliberately unanswered and excluded '
     _,←⊂'                     from the Chi-Square calculation.                          '
     _,←⊂'                     The question would then be: is the distribution of party  '
     _,←⊂'                     the same for all religions.  Row and column totals and    '
     _,←⊂'                     the grand total of the cells are calculated.  Each cell   '
     _,←⊂'                     value, if everything is "as expected", would be its row   '
     _,←⊂'                     total times its column total divided by the grand total.  '
     _,←⊂'                     The square of the sum of the deviations of cell values    '
     _,←⊂'                     from their expected values is a Chi-Square statistic with '
     _,←⊂'                     degrees-of-freedom being one less than the number of      '
     _,←⊂'                     active cells.  Chi-Square =1 : totally expected pattern   '
     _,←⊂'                                               =0 : unlikely pattern           '
     _,←⊂79⍴' '
     _,←⊂'   Result:   a namespace with the variables:                                   '
     _,←⊂'                     CT_ChiSquare_DOF  CT_Alpha  CT_Cell_Counts  CT_Deltas     '
     _,←⊂'                     CT_RowPercents  CT_ColumnPercents  CT_Overall_Percents    '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' Descrete Fourier Transforms                                                   '
     _,←⊂'       there are four functions: DFT FFT IDFT and IFFT                         '
     _,←⊂'       They all take a vector as an argument and all deliver two things:       '
     _,←⊂'             the expected output:  for DFT and FFT -- a complex vector         '
     _,←⊂'                                   for IDFT and IFFT -- a realvector           '
     _,←⊂'                                   a name space with: ComplexVector  Real Imag '
     _,←⊂'                                     Power  Phase and R_I_Matrix               '
     _,←⊂'                                     where the real and imaginary values <1E¯9 '
     _,←⊂'                                     have been forced to zero (usually created '
     _,←⊂'                                     by round-off error.                       '
     _,←⊂79⍴' '
     _,←⊂'      cvector ns  ←  DFT  x       (x is a real vector, usually a time series)  '
     _,←⊂'              The DFT is by the raw definition of a discrete transform and is  '
     _,←⊂'              of order n-squared.   That means slow for long x vectors >4000.  '
     _,←⊂'              The x vector can be of any length (an advantage).                '
     _,←⊂79⍴' '
     _,←⊂'      cvector ns  ←  FFT  x  (x is a real vector, usually a time series)       '
     _,←⊂'              The Fast Forier Transform is of order n log n.  Much faster.     '
     _,←⊂'              The length of the x vector should be a power of 2.  If it isn"t, '
     _,←⊂'              it is padded to the next power with zeros.                       '
     _,←⊂79⍴' '
     _,←⊂'      rvector ns  ← IDFT  c  (c: a complex vector, usually the output of a DFT)'
     _,←⊂'              The IDFT is by the raw definition of a inverse discrete transform'
     _,←⊂'               and is of order n-squared.   That means slow for long x vectors:'
     _,←⊂'               >4000.  The c vector can be of any length (an advantage).       '
     _,←⊂79⍴' '
     _,←⊂'      rvector ns  ← IFFT  c  (c: a complex vector, usually the output of a FFT)'
     _,←⊂'              The Fast Inverse Transform is of order n log n.  Much faster.    '
     _,←⊂'              The length of the x vector should be a power of 2.  If it isn"t, '
     _,←⊂'              it is padded to the next power with zeros.                       '
     _,←⊂79⍴' '
     _,←⊂'       You should expect  (⊃ IDFT ⊂ DFT x) to equal x to within round-off      '
     _,←⊂'                     and  (⊃ IFFT ⊂ FFT x) to equal x to within round-off      '
     _,←⊂79⍴' '
     _,←⊂'       If the padding is almost equal to the length of the data, the salient   '
     _,←⊂'       features of the power spectrum are pretty much the same when the actual '
     _,←⊂'       number of frequencies in x are few.                                     '
     _,←⊂'       Random noise of 100% of the "pure" signal leaves the bigger frequency   '
     _,←⊂'       bins recognizable!                                                      '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' LeadLag       line up the positions of sequelnced data                        '
     _,←⊂'              vov  ←  LeadLag  vov updown {fill {cut_bottom {cut_top}}}        '
     _,←⊂79⍴' '
     _,←⊂'   There are times when data are a function of time, that you need             '
     _,←⊂'   to "line stuff up".   Rainfall and river level for example.  The            '
     _,←⊂'   river sizes at a later time than when the rain fell.   What you             '
     _,←⊂'   order actually arrives later.  Some materials need to be ordered            '
     _,←⊂'   before others to have everyting ready for the construction job.             '
     _,←⊂'   Early decision college offers might be accepted earlier than                '
     _,←⊂'   regular offers.                                                             '
     _,←⊂79⍴' '
     _,←⊂'   Input:   related set (vector) of variables, (all the same length)           '
     _,←⊂'            an equal size vector of how much each variable should be           '
     _,←⊂'                 lifted (+) or pushed down (-) or left alone (0)               '
     _,←⊂'            what the "fill" value should be: "L" last value before             '
     _,←⊂'                 the fill or "Z" zero fill or "B" for blank (character         '
     _,←⊂'                 data) or a number (which could be 0).  Default=0.             '
     _,←⊂'            should the bottom of all variables be lopped off below the         '
     _,←⊂'                 bottom of the biggest "lifted" variable (1) or not (0)        '
     _,←⊂'                 Defaulted to 1.                                               '
     _,←⊂'            should the top of all variables be lopped off down to the          '
     _,←⊂'                 top of the biggest "pushed down" variable (1) or not (0)      '
     _,←⊂'                 Defaulted to 1.                                               '
     _,←⊂'   OutPut:  the shifted input data                                             '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' ModelChebyshev    make a series of Chebyshev polynomials                      '
     _,←⊂'             vop  ←  ModelChebyshev  nd order                                  '
     _,←⊂79⍴' '
     _,←⊂'   Input:      nd:  the number of data points for each polynomial              '
     _,←⊂'            order:  how many polynomials                                       '
     _,←⊂'   OutPut:  a vecctor of polynomials of increasing order                       '
     _,←⊂79⍴' '
     _,←⊂'       the advantage of these polynomials is that they are scaled ¯1 to 1 and  '
     _,←⊂'       most significantly they are orthogonal. I.e., their correlation matrix  '
     _,←⊂'       is the identity matrix.  Thus they can be used to do regressions safely '
     _,←⊂'       and the coefficients can be interpreted as slope, bend, wiggle, etc.    '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' ModelQuadratic    make every order 2 (squares and cross-products) out of vov  '
     _,←⊂'             qvov names  ←  ModelQuadratic vov                                 '
     _,←⊂79⍴' '
     _,←⊂'   Input:     vov:  a vector of data vectors                                   '
     _,←⊂'   Output:   qvov:  a vector of the squares and cross-products of the input.   '
     _,←⊂'            names:  identifiers for the qvov:  A B C D...AA BB...AB AC...BC....'
     _,←⊂'       qvov ≡  the original vectors, followed by their squares, followed by    '
     _,←⊂'               all of the unique cross prodlucts, in logical order             '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' PrincipalComponents      one orthogonalization of data                        '
     _,←⊂'             ns  ←  PrincipleComponents  data                                  '
     _,←⊂79⍴' '
     _,←⊂'   Input:  data:  a vector of vectors (padded with zeros to be of equal length)'
     _,←⊂'            or    a matrix with variables as columns                           '
     _,←⊂'   Output:   ns:  a namespace with:                                            '
     _,←⊂'        PCOMP_Table -- the entire picture of the analysis as text              '
     _,←⊂'     parts of that table  but as numbers                                       '
     _,←⊂'        PCOMP_Components -- columns in order of explained variance (numerical) '
     _,←⊂'                            indicating the "importance" of each data variable  '
     _,←⊂'                            in that component                                  '
     _,←⊂'        PCOMP_Percent -- variance explained by each component                  '
     _,←⊂'        PCOMP_CumulativePercent -- cum.% variance explained by each component  '
     _,←⊂'        PCOMP_EigenValues -- pivots generating the component matrix ("impact") '
     _,←⊂'     and                                                                       '
     _,←⊂'        PCOMP_factors -- the data expressed as "factors".  The "regression" of '
     _,←⊂'                         each data vector with the Components as coefficients  '
     _,←⊂'                         or weightings.                                        '
     _,←⊂'        PCOMP_FactorsSorted --Each factor sorted.  Indicates which data        '
     _,←⊂'                                  observations had the greatest impact.        '
     _,←⊂'        PCOMP_FactorCovarianceMatrix -- cross-product of the factors           '
     _,←⊂'        PCOMP_DataCorrelationMatrix -- correlations of the data                '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' RegressChebyshev         regression using orthogonal Chebyshev variables      '
     _,←⊂'            ns ← {var_names} RegressChebyshev y x order                        '
     _,←⊂79⍴' '
     _,←⊂'   Inputs:  right:     y:  the dependent (response) variable (Y)               '
     _,←⊂'                       x:  the independent (X) variable                        '
     _,←⊂'                   order:  the highest power Chebyshev polynomial              '
     _,←⊂'            left:  variable names for Y and X.  Defaults to "Y" and "X".       '
     _,←⊂'   Output:  a namespace with the Forsythe regression namespace, and the results'
     _,←⊂'            of the Chebyshev regression                                        '
     _,←⊂79⍴' '
     _,←⊂'      Because a Chebyshev regression requires the X values to be at particuarly'
     _,←⊂'      located positions, The data are first regressed with Forlsythe Orthogonal'
     _,←⊂'      polynomials (orthogonality insures that the regression will not fail).   '
     _,←⊂'      That regression is then used to calculate Y values at the Chebyshev X    '
     _,←⊂'      values.  Then the C_Y and C_polynomials (based on C_X) can be computed.  '
     _,←⊂'      The underlying statistics and Anova are those of the Forsythye regression'
     _,←⊂'      The reason for doing the Chebyshev regression is that the coefficients   '
     _,←⊂'      are interpretable. The first C_coefficient is the average of C_Y (not Y).'
     _,←⊂'      The second coefficient is the tilt or slope of the data.  The third is   '
     _,←⊂'      the parabolic bend to the data.  The fourth is the "cubic" wiggle.  etc. '
     _,←⊂'      Given that Chebyshev polynomials have maximum amplitudes of +-1, you get '
     _,←⊂'      a glimpse of the "shape" of your Y data.  Thus it is easy to compare sets'
     _,←⊂'      of Y data.                                                               '
     _,←⊂79⍴' '
     _,←⊂'      Things contained in the output namespace:                                '
     _,←⊂'          Results of the Fourier Regression:  its output namespace: Fourier_ns '
     _,←⊂'            as well as some extracted info:                                    '
     _,←⊂'              F_Yhat  F_Statistics  F_Residuals  F_ResultTable  F_AnovaTAble   '
     _,←⊂'              F_ResidualsTable F_DigitsLost (due to regression: usually 0)     '
     _,←⊂'          Results of the Chebyshev regression:                                 '
     _,←⊂'              C_Coefficients  C_X  C_Y  C_Yhat  C_Residuals  C_DigitsLost      '
     _,←⊂'              and the ChebyshevPolynomials                                     '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' RegressForsythe     an orthogonal regression                                  '
     _,←⊂'            ns ← {var_names} RegressForsythev y x order                        '
     _,←⊂79⍴' '
     _,←⊂'   Inputs:  right:                                                             '
     _,←⊂'                       y:  the dependent (response) variable (Y)               '
     _,←⊂'                       x:  the independent (X) variable                        '
     _,←⊂'                   order:  the highest power Chebyshev polynomial              '
     _,←⊂'            left:                                                              '
     _,←⊂'                   variable names for Y and X.  Defaults to "Y" and "X".       '
     _,←⊂'   Output:  a namespace with Forsythe regression results:                      '
     _,←⊂79⍴' '
     _,←⊂'      Because the Forsythe polynomials are orthogonal, there is no loss of     '
     _,←⊂'      accuracy in the solution due to inter-correlation of the "X" variables as'
     _,←⊂'      there is with a straight polynomial regression.                          '
     _,←⊂79⍴' '
     _,←⊂'      The name space includes:                                                 '
     _,←⊂'           X  Y  Yhat  Coefficients  Results  AnovaTable  Statistics           '
     _,←⊂'           Residuals  ResidualsTable                                           '
     _,←⊂'           ForsythePolynomialsOnX  ForsytheCoeffs                              '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' RegressFourier      a regression using sines and cosines                      '
     _,←⊂'            ns ← {var_names} RegressFourier y x order                          '
     _,←⊂79⍴' '
     _,←⊂'   Inputs:  right:     y:  the dependent (response) variable (Y)               '
     _,←⊂'                       x:  the independent (X) variable                        '
     _,←⊂'                   order:  the number of (sine and cosine) terms               '
     _,←⊂'            left:  names for Y and X.  Defaults to "Y" and "X".                '
     _,←⊂79⍴' '
     _,←⊂'   Output:  a namespace with Fourier regression results:                       '
     _,←⊂'              Names X  Y  Yhat  Residuals  ResidualsTable                      '
     _,←⊂'              AnovaTable  Results  Statistics  DigitsLost                      '
     _,←⊂'              FourierXmatrix:  columns:  1  Sine Cosine S C S C ...            '
     _,←⊂'              Coefficients:    constant sine cos sin cos ...                   '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' RegressMultipleLinear      standard regression (not done as y⌹x)              '
     _,←⊂'            ns  ←  (var_names) RegressMultipleLinear y vov                     '
     _,←⊂79⍴' '
     _,←⊂'   Inputs:  right:     y:  the dependent (response) variable (Y)               '
     _,←⊂'                     vov:  the independent (X) variables (vectors)             '
     _,←⊂'            left:  names for Y and Xs.  Defaults to "Y" and "X1" "X2" "X3" ... '
     _,←⊂79⍴' '
     _,←⊂'   Output:  a namespace with regression results:                               '
     _,←⊂'              Xmatrix  Y  Yhat  Residuals  ResidualsTable                      '
     _,←⊂'              AnovaTable  Results  Statistics  DigitsLost  ConditionNumber     '
     _,←⊂'              Coefficients  Coefs_byQuadDivide  X_names  Y_name                '
     _,←⊂'              Max_Covariance  X_CorrelationMatrix                              '
     _,←⊂79⍴' '
     _,←⊂'         If you are working on a 16 digit platform, 16-DigitsLost is about how '
     _,←⊂'         many reliable digits there are in the coefficients.  If that is less  '
     _,←⊂'         3, I wouldn"t trust the results (due to correlation between the Xs).  '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' RegressPolynomial      standard regression on powers of x (not done as y⌹x)   '
     _,←⊂'            ns  ←  (var_names) RegressPolynomial y x                           '
     _,←⊂79⍴' '
     _,←⊂'   Inputs:  right:     y:  the dependent (response) variable (Y)               '
     _,←⊂'                       x:  the independent (X) variable                        '
     _,←⊂'            left:  names for Y and Xs.  Defaults to "Y" and "X1" "X2" "X3" ... '
     _,←⊂79⍴' '
     _,←⊂'   Output:  a namespace with regression results:                               '
     _,←⊂'              Xmatrix  X  Y  Yhat  Residuals  ResidualsTable                   '
     _,←⊂'              AnovaTable  Results  Statistics  DigitsLost  ConditionNumber     '
     _,←⊂'              Coefficients  Coefs_byQuadDivide  X_names  Y_name                '
     _,←⊂'              Max_Covariance  X_CorrelationMatrix                              '
     _,←⊂79⍴' '
     _,←⊂'         If you are working on a 16 digit platform, 16-DigitsLost is about how '
     _,←⊂'         many reliable digits there are in the coefficients.  If that is less  '
     _,←⊂'         3, I wouldn"t trust the results (due to correlation between the Xs).  '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' SimultaneousEquations        solve a set of linear algebraic equations        '
     _,←⊂'                 soln_vector  digits_lost  ←  SimultaneousEquations Amat Rhs   '
     _,←⊂79⍴' '
     _,←⊂'   Inputs:  Amat -- the coefficients matrix                                    '
     _,←⊂'             Rhs -- the right hand side                                        '
     _,←⊂79⍴' '
     _,←⊂'   The solutions is not done by:  Rhs ⌹ Amat , but rather in a manner that     '
     _,←⊂'   checks the pivots to estimate digit_lost.   When working on a 16 digit      '
     _,←⊂'   platform, 16-digits_lost is about how many reliable digits there are in the '
     _,←⊂'   solution.  If this falls below 3, I wouldn"t trust the results at all.      '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' Statistics           get means, std.dev, etc for a set of x vectors           '
     _,←⊂'               ns  ←  {names}  Statistics  vov                                 '
     _,←⊂79⍴' '
     _,←⊂'   Input:      vov:  a vector of variable vectors.                             '
     _,←⊂'             names:  optional names for the variables                          '
     _,←⊂'   Output:   ns:  a namespace containing:                                      '
     _,←⊂'                  StatisticsTable  Data_vov                                    '
     _,←⊂'                  DataMatrix (padded with zeros if necessary)                  '
     _,←⊂'                  CorrelationMatrix (of DataMatrix)                            '
     _,←⊂'                  and all of the measures in the table individually numerical  '
     _,←⊂'                      vectors, just in case you want to use them.              '
     _,←⊂79⍴' '
     _,←⊂'                  Statistics table lists for each variable:                    '
     _,←⊂'                      IndesCount  Average  Min  Max  Std_dev  Skew  Kurtosis   '
     _,←⊂'                      Coefficient_of_variation  %_=_0  %_near_0  {name}        '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' StepWiseAll       multiple linear regression all allowable variables per step '
     _,←⊂'            ns  ←  {yxnames}  StepWiseAll  y  vox  fi  fo (starting_indecies)  '
     _,←⊂79⍴' '
     _,←⊂'   Inputs:      y:  the dependent variable to be fitted with x                 '
     _,←⊂'              vox:  a vector of the independent variables                      '
     _,←⊂'               fi:  the lower limit of Fratio among the "out" variables that   '
     _,←⊂'                    will determine it they are allowed "in".                   '
     _,←⊂'               fo:  the Fratio limit below which an "in" variable will be      '
     _,←⊂'                    kicked out.                                                '
     _,←⊂'               si:  The indecies of x variables that are initially "in" the    '
     _,←⊂'                    regression.  This can include any legitimate index,        '
     _,←⊂'                    including ⍬ and all of them.                               '
     _,←⊂'          yxnames:  a vector of optional variable names starting with the Y    '
     _,←⊂'                    variable.  It must have 1+#_of_X_variables text names.     '
     _,←⊂79⍴' '
     _,←⊂'   Output:  ns:  a namespace containing for the final regression:              '
     _,←⊂'                     AnovaTable            distribution of sums_of_squares     '
     _,←⊂'                     Coefficients          not done by y⌹x                     '
     _,←⊂'                     Results               stats for each variable             '
     _,←⊂'                     Coefs_byQuadDivide                                        '
     _,←⊂'                     DigitsLost            on a 16 digit platform 16-DL <3 or 4'
     _,←⊂'                                           is worrisome                        '
     _,←⊂'                     ConditionNumber                                           '
     _,←⊂'                     In_Indecies  Out_Indecies                                 '
     _,←⊂'                     In_Names  Out_Names                                       '
     _,←⊂'                     Y_name     X_names                                        '
     _,←⊂'                     Max_Covariance                                            '
     _,←⊂'                     Statistics            including residuals analyses        '
     _,←⊂'                     Xmatrix  Y  Yhat                                          '
     _,←⊂'                     Residuals             (Y-Yhat)                            '
     _,←⊂'                     ResidualTable                                             '
     _,←⊂'                     X_CorrelationMatrix   of the "in"s                        '
     _,←⊂'                 and for the process:                                          '
     _,←⊂'                     InOut_path            what happened at each step          '
     _,←⊂'                     In_Table              statistics for each step regression '
     _,←⊂'                     Out_Table             statistics for each step regression '
     _,←⊂'                     progress              the Fratios along the way           '
     _,←⊂'                     NsIn   NsOut          the last step"s regression info     '
     _,←⊂79⍴' '
     _,←⊂'      If you believe that the regression should include a constant, one of the '
     _,←⊂'      x variables (usually the first) should be all ones.                      '
     _,←⊂79⍴' '
     _,←⊂'      This regression process is iterative.  At each pass a regression is done '
     _,←⊂'      on the "in" variables and on the "out" variables.  This provides Fratios '
     _,←⊂'      that determine if any "in"s should be removed and if any "outs" should be'
     _,←⊂'      added to the "in"s.  Although most of the time this is done in one pass, '
     _,←⊂'      that is not necessarilly so.  The steps taken are itemized in the output '
     _,←⊂'      namespace as the variable:  InOut_path.                                  '
     _,←⊂79⍴' '
     _,←⊂'      All regressions are done by row reduction in order to watch the pivots   '
     _,←⊂'      to measure the degree of singularity of the  process.  This is           '
     _,←⊂'      particularly relevant in regressons involving correlated xs.  On a 16    '
     _,←⊂'      digit platform, losing 7 or 8 digits leaves answers good to 9 or 8       '
     _,←⊂'      digits.  Losing more than 13 means that you probably can"t believe the   '
     _,←⊂'      results at all.                                                          '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' StepWiseOne       multiple linear regression only one variable at a time      '
     _,←⊂'            ns  ←  {yxnames}  StepWiseOne  y  vox  fi  fo (starting_indecies)  '
     _,←⊂79⍴' '
     _,←⊂79⍴' '
     _,←⊂' StepWiseAll       multiple linear regression allowable steps at a time        '
     _,←⊂'            ns  ←  {yxnames}  StepWiseAll  y  vox  fi  fo (starting_indecies)  '
     _,←⊂79⍴' '
     _,←⊂'   Inputs:      y:  the dependent variable to be fitted with x                 '
     _,←⊂'              vox:  a vector of the independent variables                      '
     _,←⊂'               fi:  the lower limit of Fratio among the "out" variables that   '
     _,←⊂'                    will determine it they are allowed "in".                   '
     _,←⊂'               fo:  the Fratio limit below which an "in" variable will be      '
     _,←⊂'                    kicked out.                                                '
     _,←⊂'               si:  The indecies of x variables that are initially "in" the    '
     _,←⊂'                    regression.  This can include any legitimate index,        '
     _,←⊂'                    including ⍬ and all of them.                               '
     _,←⊂'          yxnames:  a vector of optional variable names starting with the Y    '
     _,←⊂'                    variable.  It must have 1+#_of_X_variables text names.     '
     _,←⊂79⍴' '
     _,←⊂'   Output:  ns:  a namespace containing for the final regression:              '
     _,←⊂'                     AnovaTable            distribution of sums_of_squares     '
     _,←⊂'                     Coefficients          not done by y⌹x                     '
     _,←⊂'                     Results               stats for each variable             '
     _,←⊂'                     Coefs_byQuadDivide                                        '
     _,←⊂'                     DigitsLost            on a 16 digit platform 16-DL <3 or 4'
     _,←⊂'                                           is worrisome                        '
     _,←⊂'                     ConditionNumber                                           '
     _,←⊂'                     In_Indecies  Out_Indecies                                 '
     _,←⊂'                     In_Names  Out_Names                                       '
     _,←⊂'                     Y_name     X_names                                        '
     _,←⊂'                     Max_Covariance                                            '
     _,←⊂'                     Statistics            including residuals analyses        '
     _,←⊂'                     Xmatrix  Y  Yhat                                          '
     _,←⊂'                     Residuals             (Y-Yhat)                            '
     _,←⊂'                     ResidualTable                                             '
     _,←⊂'                     X_CorrelationMatrix   of the "in"s                        '
     _,←⊂'                 and for the process:                                          '
     _,←⊂'                     InOut_path            what happened at each step          '
     _,←⊂'                     In_Table              statistics for each step regression '
     _,←⊂'                     Out_Table             statistics for each step regression '
     _,←⊂'                     progress              the Fratios along the way           '
     _,←⊂'                     NsIn   NsOut          the last step"s regression info     '
     _,←⊂79⍴' '
     _,←⊂'      If you believe that the regression should include a constant, one of the '
     _,←⊂'      x variables (usually the first) should be all ones.                      '
     _,←⊂79⍴' '
     _,←⊂'      This regression process is iterative.  At each pass a regression is done '
     _,←⊂'      on the "in" variables and on the "out" variables.  This provides Fratios '
     _,←⊂'      that determine if any "in"s should be removed and if any "outs" should be'
     _,←⊂'      added to the "in"s.  First one out→in variable will be chosen if one is  '
     _,←⊂'      available.  When all "out"s can"t get in, one "in" variable is selected  '
     _,←⊂'      if available.  When no variable can move the process stops.  The steps   '
     _,←⊂'       taken are itemized in the output namespace as the variable:  InOut_path '
     _,←⊂79⍴' '
     _,←⊂'      All regressions are done by row reduction in order to watch the pivots   '
     _,←⊂'      to measure the degree of singularity of the  process.  This is           '
     _,←⊂'      particularly relevant in regressons involving correlated xs.  On a 16    '
     _,←⊂'      digit platform, losing 7 or 8 digits leaves answers good to 9 or 8       '
     _,←⊂'      digits.  Losing more than 13 means that you probably can"t believe the   '
     _,←⊂'      results at all.                                                          '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' TukeyWindow      "round off" the ends of a vector                             '
     _,←⊂'                  wv  ←  {window_width}  TukeyWindow  v                        '
     _,←⊂79⍴' '
     _,←⊂'   Inputs:       v:  a reasonably long vector                                  '
     _,←⊂'               w_w:  optionally the fraction of the data effected at each end. '
     _,←⊂'                     Defaults to .25; affecting a quarter of the input vector  '
     _,←⊂'                     on each end.                                              '
     _,←⊂'   Output:      wv:  the windowed vector.                                      '
     _,←⊂79⍴' '
     _,←⊂'          v is usually a sound signal: music, speech, an accustic event or     '
     _,←⊂'          noise recording                                                      '
     _,←⊂'.                                                                              '
     _,←⊂'          Apply the original Tukey-Interim-Window.  This is "cosine" rounding  '
     _,←⊂'          at each end of a time string to improve the apparent power spectrum  '
     _,←⊂'          and Fourier Transform (DFT and FFT).  Sharp "edges" cause spurious   '
     _,←⊂'          harmonics in the FFT, and this is supposed to reduce that problem.   '
     _,←⊂79⍴' '
     _,←⊂'     cosine: goes 1 to ¯1  <::>  1-cos  goes 0 to 2  <::>  ÷ by 2  goes 0 to 1 '
     _,←⊂79⍴' '
     _,←⊂'                                 *---.....---*                                 '
     _,←⊂'                              *                 *                              '
     _,←⊂'                           *                       *                           '
     _,←⊂'                          *                         *                          '
     _,←⊂'                         *                           *                         '
     _,←⊂'                      *                                 *                      '
     _,←⊂'                ****                                       ****                '
     _,←⊂79⍴' '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴'='
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' Distrib      a namespace with functions that calculate various distributions. '
     _,←⊂79⍴' '
     _,←⊂'             P p :: the cumulative probability (integral from the left (1-⍺)   '
     _,←⊂'             A ⍺ :: the tail probability (integral to the right)      (1-p)    '
     _,←⊂'             C c :: critical ChiSquare                                         '
     _,←⊂'             D d :: degrees of freedom:   DOF  (for F_ratio: denominator DOF)  '
     _,←⊂'             N n :: degrees of freedom:   numerator DOF for F_ratio            '
     _,←⊂'             F f :: critical F_ratio                                           '
     _,←⊂'          big letter ≡ return  ⋄  little letters ≡ RighttHandArg               '
     _,←⊂79⍴' '
     _,←⊂79⍴' '
     _,←⊂79⍴'-'
     _,←⊂' Normal:    ⍺ ← Normal_A     x      you give it x, it returns ⍺ (tail beyond x)'
     _,←⊂'            p ← Normal_P     x      returns integral up to x                   '
     _,←⊂'            y ← Normal_y     x      the ordinate of the normal curve at x      '
     _,←⊂'            x ← Normal_Xa    ⍺      returns the x for that ⍺                   '
     _,←⊂'            x ← Normal_Xp    p      returns the x for that cumulative dist.    '
     _,←⊂79⍴' '
     _,←⊂79⍴' '
     _,←⊂79⍴'-'
     _,←⊂' student t: ⍺ ← Student_A    t dof  return ⍺ for a given t and deg_of_freedom  '
     _,←⊂'            p ← Student_P    t dof  return p   the most common usage           '
     _,←⊂'            ⍺ ← Student_Atd  t dof  return ⍺   same as Student_A but consistant'
     _,←⊂'            p ← Student_Ptd  t dof  return p                                   '
     _,←⊂79⍴' '
     _,←⊂'            t ← Student_Tad  ⍺ dof  return t                                   '
     _,←⊂'            t ← Student_Tpd  p dof  return t                                   '
     _,←⊂'            d ← Student_Dta  t ⍺    return Degrees_Of_Freedom  (DOF)           '
     _,←⊂'            d ← Student_Dtp  t p    return DOF                                 '
     _,←⊂79⍴' '
     _,←⊂79⍴' '
     _,←⊂79⍴'-'
     _,←⊂' ChiSquare: ⍺ ← ChiSq_A      c dof  given ChiSq and DOF return alpha           '
     _,←⊂'            p ← ChiSq_P      c dof  given ChiSq and DOF return p (cum. dist.)  '
     _,←⊂'            ⍺ ← ChiSq_Acd    c dof  given ChiSq and DOF return alpha           '
     _,←⊂'            p ← ChiSq_Pcd    c p    given ChiSq and DOF return p               '
     _,←⊂79⍴' '
     _,←⊂'            c ← ChiSq_Cad    ⍺ dof  given ⍺ and dof return critical ChiSquare  '
     _,←⊂'            c ← ChiSq_Cpd    p dof  given cum.dist. return critical ChiSquare  '
     _,←⊂'            d ← ChiSq_Dca    c ⍺    given ChiSq and ⍺ return DOF               '
     _,←⊂'            d ← ChiSq_Dcp    c p    given ChiSq and p return DOF               '
     _,←⊂79⍴' '
     _,←⊂'            ? ← ChiSq_CAD    c ⍺ d  substitute one of inputs with ⍬, get that  '
     _,←⊂'                                    c ← ChiSq_CAD ⍬ ⍺ d                        '
     _,←⊂'                                    ⍺ ← ChiSq_CAD c ⍬ d                        '
     _,←⊂'                                    d ← ChiSq_CAD c ⍺     or C ⍺ ⍬             '
     _,←⊂'            ? ← ChiSq_CPD    c p d  substitute one of inputs with ⍬, get that  '
     _,←⊂79⍴' '
     _,←⊂79⍴'-'
     _,←⊂' F_ratio    ⍺ ← Fratio_A     F n d  return ⍺    the most common usage          '
     _,←⊂'            p ← Fratio_P     F n d  return p    "                              '
     _,←⊂'            ⍺ ← Fratio_Afnd  F n d  return ⍺    same as Fratio_A but consistant'
     _,←⊂'            p ← Fratio_Pfnd  F n d  return p                                   '
     _,←⊂79⍴' '
     _,←⊂'            f ← Fratio_Fand  ⍺ n d  return critical F_ratio                    '
     _,←⊂'            f ← Fratio_Fpnd  p n d  return critical F_ratio                    '
     _,←⊂'            n ← Fratio_Nfad  f ⍺ d  return critical F_ratio                    '
     _,←⊂'            n ← Fratio_Nfpd  f p d  return critical F_ratio                    '
     _,←⊂'            d ← Fratio_Dfan  f ⍺ d  return critical F_ratio                    '
     _,←⊂'            d ← Fratio_Dfpn  f p n  return critical F_ratio                    '
     _,←⊂79⍴' '
     _,←⊂'            ? ← Fratio_FAND  f ⍺ n d  subst. 1 arg. with ⍬, get that one       '
     _,←⊂'            ? ← Fratio_FPND  f p n d  subst. 1 arg. with ⍬, get that one       '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     _,←⊂79⍴'='
     _,←⊂79⍴'='
     _,←⊂79⍴' '
     _,←⊂' Dutils    a namespace with functions used by the statistical and distributio  '
     _,←⊂'           functions.  Not particularly for general use (but not worthless).   '
     _,←⊂79⍴' '
     _,←⊂79⍴'='
     ↑_
 }
